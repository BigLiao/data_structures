// 用队列求解迷宫问题
#define MAXSIZE 1000

// 构造一个迷宫，1代表墙，0代表通道
// 入口为[2][2]，出口为[8][8]
int maze[10][10] = {
  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
  { 1, 0, 0, 1, 0, 0, 0, 1, 0, 1 },
  { 1, 0, 0, 1, 0, 0, 0, 1, 0, 1 },
  { 1, 0, 0, 0, 0, 1, 1, 0, 0, 1 },
  { 1, 0, 1, 1, 1, 0, 0, 0, 0, 1 },
  { 1, 0, 0, 0, 1, 0, 0, 0, 0, 1 },
  { 1, 0, 1, 0, 0, 0, 1, 0, 0, 1 },
  { 1, 0, 1, 1, 1, 0, 1, 1, 0, 1 },
  { 1, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
};

struct {
  int i, j;
  int pre; // 储存上一个路径在 Qu 中的下标
} Qu[MAXSIZE];
int front = -1, rear = -1; // 队列的首尾指针

void print (int front) {
  // 递归打印出路径
  printf("\t(%d, %d)", Qu[front].i, Qu[front].j);
  if (Qu[front].i == 2 && Qu[front].j == 2) {
    printf("/n 打印结束");
    return;
  }
  int k = Qu[front].pre;
  print(k);
}